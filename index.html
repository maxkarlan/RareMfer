<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SparklingMfer</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <!-- If you're not using ES6 modules in your JS, you can remove type="module" -->
    <script>
let images = [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null];
const transparencyThreshold = 128;
const numOfStreams = 250;
let imgCenter; 
let pointImageOverlapCache = {};  
let squareSize;
let streamGroups = [];
let desiredStreamCounts = [];
let totalStreamsToGenerate = 0;
let BASE_WINDOW_SIZE = 1000; // Reference window size
let windowSizeFactor = 1;
const REF_AREA = 1920 * 1080;  // Assuming 1920x1080 as the reference resolution where numOfStreams was 900.
const BASE_SPEED = .01;  // the basic speed when there's just one stream
const LOG_SCALE_FACTOR = 1.5;  // scaling factor for logarithmic relationship
//const SPEED_INCREMENT = 0.01;  // the amount of speed to be added for each additional stream


function preload() {
    squareSize = Math.min(windowWidth, windowHeight);
    let desiredImageHeight = squareSize * 2; // Adjust this factor to change image size relative to the square

    images = ["images/blueHat.png", "images/body.png", "images/face.png", "images/face2.png", "images/greenHat.png", "images/head.png", "images/head2.png", "images/headphone.png", "images/lens.png", "images/propeller.png", "images/redHat.png", "images/vr.png", "images/seat.png", "images/smile.png", "images/yellowHat.png"];
    for (let i = 0; i < 15; i++) {
        loadImage(images[i], img => {
            let scaleFactor = desiredImageHeight / img.height;
            img.resize(img.width * scaleFactor, img.height * scaleFactor);
            images[i] = img;
        });
    }
}

function getCurrentAttractMode() {
    // If no streams exist, default to true
    if (streamGroups.length === 0 || streamGroups[0].length === 0) {
        return true;
    }
    return streamGroups[0][0].attractMode;
}

// Adjust the generateStreams function to scale the number of streams based on window size
function generateStreams() {
    let areaRatio = (squareSize * squareSize) / (BASE_WINDOW_SIZE * BASE_WINDOW_SIZE);
    let adjustedNumOfStreams = Math.round(numOfStreams * areaRatio + 1850);

    const percentages = [0.05, .15, .015, .015, .15, .05, .015, .15, .05, .1, .015, .065, .05, .015, .05];
    desiredStreamCounts = [];

    for (let j = 0; j < 15; j++) {
        let desiredCountForImage = Math.round(adjustedNumOfStreams * percentages[j]);
        desiredStreamCounts.push(desiredCountForImage);
    }
    
    totalStreamsToGenerate = adjustedNumOfStreams;
}



function setup() {
    squareSize = Math.min(windowWidth, windowHeight);
    createCanvas(squareSize, squareSize);
    
    windowSizeFactor = squareSize / BASE_WINDOW_SIZE;
    
    imgCenter = createVector(width / 2, height / 2);
    background(255, 226, 95);

    for (let i = 0; i < 15; i++) {
        streamGroups.push([]);
    }

    generateStreams();
}

function windowResized() {
    squareSize = Math.min(windowWidth, windowHeight);
    resizeCanvas(squareSize, squareSize);
    
    windowSizeFactor = squareSize / BASE_WINDOW_SIZE;
    
    imgCenter.set(width / 2, height / 2);
    
    let desiredImageHeight = squareSize * 2;
    
    for (let i = 0; i < images.length; i++) {
        let img = images[i];
        if (img) {
            let scaleFactor = desiredImageHeight / img.height;
            img.resize(img.width * scaleFactor, img.height * scaleFactor);
        }
    }
    
    generateStreams();
}


function isOverAnyImageCached(point) {
let cacheKey = `${point.x},${point.y}`;

// Use the cached result if available
if (pointImageOverlapCache.hasOwnProperty(cacheKey)) {
return pointImageOverlapCache[cacheKey];
}

let result = isOverAnyImage(point);
pointImageOverlapCache[cacheKey] = result;  // Cache the result

return result;
}

function draw() {
    background(255, 226, 95);
    pointImageOverlapCache = {};  // Clear the cache for each frame
    drawTransparentSquare();

    adjustStreams();  // Adjust the number of streams

    for (let streams of streamGroups) {
        for (let s of streams) {
            s.update();
            s.display();
        }
    }
}

// New function to adjust the number of streams
function adjustStreams() {
    const colors = [
        [49, 94, 255],
        [0, 0, 0],
        [184, 159, 126],
        [204, 182, 154],
        [0, 255, 0],
        [98, 73, 52],
        [142, 117, 96],
        [255, 255, 255],
        [0, 0, 0],
        [49, 94, 255],
        [255, 0, 0],
        [110, 219, 255],
        [0, 0, 0],
        [0, 0, 0],
        [255, 241, 0]
    ];

    for (let j = 0; j < 15; j++) {
        while (streamGroups[j].length < desiredStreamCounts[j]) {
            // Sample a point from an existing stream if available
            let samplePoint = streamGroups[j].length > 0 ? random(random(streamGroups[j]).points) : null;

            // Add a stream with the sampled point
            streamGroups[j].push(new Stream(colors[j], j, samplePoint));
        }

        while (streamGroups[j].length > desiredStreamCounts[j]) {
            // Start fading the last stream
            streamGroups[j][streamGroups[j].length - 1].fade();
            
            // Remove the stream if it's fully faded
            if(streamGroups[j][streamGroups[j].length - 1].alpha <= 0) {
                streamGroups[j].pop();
            } else {
                break; // Only fade one stream at a time for smoother effect
            }
        }
        
    }
}

function drawTransparentSquare() {
    fill(255, 255, 255, 220); // White color with some transparency
    noStroke();
    rectMode(CENTER);
    rect(width / 2, height / 2, squareSize * 0.95, squareSize * 0.95);
}

function isInsideSquare(point) {
    let halfSize = squareSize * 0.95 / 2;
    return (
        point.x >= width / 2 - halfSize &&
        point.x <= width / 2 + halfSize &&
        point.y >= height / 2 - halfSize &&
        point.y <= height / 2 + halfSize
    );
}

function mousePressed() {
for (let streams of streamGroups) {
for (let s of streams) {
    s.changeMode();
}
}
}



class Stream {
    constructor(color, assignedImageIdx, startPoint = null) {
        this.color = color;
        this.points = [];
        this.noiseOffset = random(1000);
        this.currentAngle = random(TWO_PI);
        this.attractMode = getCurrentAttractMode();
        this.assignedImageIdx = assignedImageIdx;
        this.initStream(startPoint);
        this.insideImage = this.isOverAssignedImage(this.points[0]);
        this.baseAlpha = 255;
        this.currentAlpha = this.baseAlpha;
    }
    

    changeMode() {
        this.attractMode = !this.attractMode;
    }

    fade() {
        this.alpha -= 200;  // Decrement by 5 for a moderate fading speed. Adjust as needed.
    }
  
      isOverAnyImage(point) {
                return isOverAnyImageCached(point);  // Use the cached function instead
                }

                initStream(startPoint = null) {
                    if (startPoint) {
                        this.points.push(startPoint);
                    } else {
                        let startX = random(width);
                        let startY = random(height);
            
                        while (this.isOverAnyImage(createVector(startX, startY))) {
                            startX = random(width);
                            startY = random(height);
                        }
            
                        this.points.push(createVector(startX, startY));
                    }
                }

    isOutsideAllImages(point) {
        return !this.isOverAnyImage(point);
    }

    isOverAnyImage(point) {
        for (let img of images) {
            if (this.isOverImage(point, img)) return true;
        }
        return false;
    }

    isOverAssignedImage(point) {
        return this.isOverImage(point, images[this.assignedImageIdx]);
    }

    isOverImage(point, img) {
        let imgX = point.x - (width / 2 - img.width / 2);
        let imgY = point.y - (height / 2 - img.height / 2);
        if (imgX >= 0 && imgX < img.width && imgY >= 0 && imgY < img.height) {
            let pixelColor = img.get(imgX, imgY);
            return alpha(pixelColor) > transparencyThreshold && isInsideSquare(point);
        }
        return false;
    }
  
      stayWithinBounds(point) {
const buffer = 5;  // Small buffer to ensure that the stream doesn't touch the edge
if (point.x <= buffer || point.x >= width - buffer) {
this.currentAngle = PI - this.currentAngle;  // Reflect horizontally
}
if (point.y <= buffer || point.y >= height - buffer) {
this.currentAngle = -this.currentAngle;  // Reflect vertically
}
}

get totalStreamsCount() {
    let totalStreams = 0;
    for (let streams of streamGroups) {
        totalStreams += streams.length;
    }
    return totalStreams;
}

update() {
    let lastPoint = this.points[this.points.length - 1];
        let newPoint;

        // Adjust speeds based on window size
        const FASTER_BASE_SPEED = 0.05 * windowSizeFactor;
        const FASTER_LOG_SCALE_FACTOR = 2.5 * windowSizeFactor;
        const FASTER_REPEL_SPEED = 20 * windowSizeFactor;

        let speed = this.attractMode 
            ? FASTER_BASE_SPEED + FASTER_LOG_SCALE_FACTOR * Math.log(this.totalStreamsCount + 1)
            : FASTER_REPEL_SPEED;

if (this.attractMode) {
if (this.isOutsideAllImages(lastPoint) || this.insideImage || this.isOverAssignedImage(lastPoint)) {
    this.currentAngle = this.calculateAngleTowardsImage(lastPoint, this.assignedImageIdx);
}
} else {
if (this.isOverAnyImage(lastPoint)) {
    // Repulsion mechanism: If point is inside any image, move away from the image center
    this.currentAngle = this.calculateAngleAwayFromClosestImageCenter(lastPoint);
}
}

let angleVariation = map(noise(this.noiseOffset), 0, 1, -PI, PI) * windowSizeFactor;
        this.currentAngle += angleVariation;

        newPoint = p5.Vector.fromAngle(this.currentAngle).mult(speed).add(lastPoint);

// If in attractMode and inside assigned image, check if the new point is outside
if (this.attractMode && this.insideImage && !this.isOverAssignedImage(newPoint)) {
this.currentAngle += PI; // Flip direction
newPoint = p5.Vector.fromAngle(this.currentAngle).mult(speed).add(lastPoint); // Using the speed variable here too
}

this.stayWithinBounds(newPoint);  // Check and adjust for bounds

this.points.push(newPoint);
this.noiseOffset += 0.01 * windowSizeFactor;

if (this.points.length > 100 * windowSizeFactor) {
    this.points.shift();
}

        // Update the insideImage flag and adjust alpha
        this.insideImage = this.isOverAssignedImage(lastPoint);
        this.updateAlpha();
}

stayWithinBounds(point) {
        const buffer = 5 * windowSizeFactor;  // Adjust buffer based on window size
        if (point.x <= buffer || point.x >= width - buffer) {
            this.currentAngle = PI - this.currentAngle;
        }
        if (point.y <= buffer || point.y >= height - buffer) {
            this.currentAngle = -this.currentAngle;
        }
    }

updateAlpha() {
        // Indices for leftEye.png and rightEye.png (adjust these if necessary)
        const headphoneIndex = 7;  // Assuming headphone.png is at index 7
        const leftEyeIndex = 8;  // Assuming leftEye.png is at index 10
        const rightEyeIndex = 11; // Assuming rightEye.png is at index 13

        // // If the stream is associated with eye images, always keep it fully opaque
        // if (this.assignedImageIdx === leftEyeIndex || this.assignedImageIdx === rightEyeIndex) {
        //     this.currentAlpha = this.baseAlpha;
        //     return;
        // }

        const targetAlpha = this.insideImage ? this.baseAlpha : 60; // Full opacity when over image, 20% when not
        const alphaChangeSpeed = 10; // Adjust this value to change how quickly alpha transitions

        if (this.currentAlpha < targetAlpha) {
            this.currentAlpha = Math.min(this.currentAlpha + alphaChangeSpeed, targetAlpha);
        } else if (this.currentAlpha > targetAlpha) {
            this.currentAlpha = Math.max(this.currentAlpha - alphaChangeSpeed, targetAlpha);
        }
    }

    calculateAngleAwayFromClosestImageCenter(point) {
        let closestDistance = Infinity;
        let closestImageCenter;

        for (let img of images) {
            let distance = dist(point.x, point.y, imgCenter.x, imgCenter.y);
            if (distance < closestDistance && this.isOverImage(point, img)) {
                closestDistance = distance;
                closestImageCenter = imgCenter;
            }
        }

        if (closestImageCenter) {
            return p5.Vector.sub(point, closestImageCenter).heading();
        }
        
        return random(TWO_PI);
    }

    calculateAngleTowardsImage(point, imgIdx) {
        if (this.insideImage) {
            return random(TWO_PI);
        }
        let angleTowardsImage = p5.Vector.sub(imgCenter, point).heading();
        return angleTowardsImage;
    }

    fade() {
        this.baseAlpha -= 5; // Adjust the fade speed as needed
        this.currentAlpha = Math.min(this.currentAlpha, this.baseAlpha);
    }

    display() {
        noFill();
        stroke(this.color[0], this.color[1], this.color[2], this.currentAlpha);
        strokeWeight(0.2 * windowSizeFactor);  // Adjust stroke weight based on window size
        beginShape();
        for (let pt of this.points) {
            vertex(pt.x, pt.y);
        }
        endShape();
    }
}
    </script>
</body>

</html>